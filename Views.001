AK155 07-06-2004 <Views.pas> Views.001
(Текст к патчу ak40607a.dif)

Началось всё вот с чего:

========================== RU.SHELL.DN ==============================
   From: Sasha Leshinsky            2:5030/870  06 Jun 2004  11:58:30
     To: ALL                                    07 Jun 2004  02:45:20
   Subj: Бага в b16/Win32
====================================================================
добрый вечер

Переходим курсором на правую панель.
Левую скрываем (CTRL+F1)
Hа любом файле/каталоге нажимаем ALT+F6 и видим:


=== CUT ===
Dos Navigator /2 Open Source  1.51.10b16╔═[1]════════════ C:
                                        ║       Name       │
                                        ║..                │
║1                 │                    ║1                 │
                                        ║2                 │
=== CUT ===
====================================================================

     Откат версий быстро выявил момент возникновения глюка: b13, патч
ak30812a.dif based on dn368-quick_rename_fix.patch by Sergey Biryukov.
В DN OSP этого глюка нет.

     Отличие с DN OSP заключалось в отсутствии (fltools.pas,
CM_RenameSingleL) вызова P^.Owner^.Insert(PIF) вот в таком контексте:

P^.Owner^.Insert(PIF); P^.Owner^.ExecView(PIF) (до патча) и
P^.Owner^.Insert(PIF); Desktop^.ExecView(PIF) (после патча).

     Тут  я погорячился: выбросил лишнюю команду, не осознав, что он
*была* лишней, а после патча *стала* очень даже не лишней.
Работает она очень хитро.
     Во-первых,  координаты  PIF вычислялись относительно менеджера,
так  что  они  оказываются неправильными при вставке в десктоп, если
менеджер не прижат к левому верхнему углу - на это и наткнулся юзер.
Но  это мелочь. Что более существенно, так это то, что по нажатию F1
вызывается    хелп,    а    по   Esc   закрывается   с   сохранением
работоспособности строки ввода имени файла. Это как раз правильная с
точке зрения юзера работа хелпа.

     А  если вычислить координаты относительно десктопа и вставить в
десктоп  (неявно,  за счёт ExecView), то после закрытия хелпа строка
ввода  тоже  закрывается.  Я  не  анализировал детально причину, но,
вероятно, дело в том, что десктоп при активизации (модального) хелпа
снимает модальность со строки ввода и делает это путём её прибития.
     А  в работающем варианте получается, что строка ввода вставлена
в  менеджер,  но делается Current в десктопе, так что хелп модален в
десктопе,  а  строка  ввода  - в менеджере. И после завершения хелпа
строка ввода жива-здорова.

     Причиной  этого  патча  было  то,  что  хелп  по  F1  получался
немодальный.  Так  что по Esc закрывалась строка ввода, а не хелп, а
если  как-то  вернуть  фокус  менеджеру,  то  хелп  вообще оставался
висеть.

     Для  beta  16  stable  надо  будет  просто  вставить P^.Owner^.
Insert(PIF). Но для 2.06 такое малодушие не годится :)


     Тогда я стал смотреть, как, собственно, запускается окно хелпа,
и нашёл вот такое сооружение (dnutil.pas, обработка cmHelp):

            if  ( (Desktop^.Current <> nil)
                and (
                    (Desktop^.Current^.GetState(sfModal)) or
                    (Desktop^.Current^.GetState(sfDragging))
                  )
                ) or MenuActive
            then
              ExecView(HelpWnd)
            else
              begin
              HelpWnd^.SetState(sfModal, False);
              HelpWnd^.Options := HelpWnd^.Options or ofTileable or
                 ofTopSelect;
              Application^.InsertWindow(HelpWnd);
              Exit;
              end;

     То   есть  модальный хелп для модального окна вызывается только
если   оно вставлено в десктоп. А если во что-то другое - хелп будет
немодальный  со  всеми  вытекающими  из  этого  глюками.  Ну  и, как
водится,   вместо   того,   чтобы  устранить  источник  болезни,  мы
занимались подавлением симптомов.

     Самое  просто  решение  -  сделать  хелп  всегда модальным. Но,
боюсь,  это может многим не понравиться, так как исключает неспешное
чтение  хелпа  в  параллель  с выполнением соответствующих действий.
Впрочем,  для  многозадачки это едва ли существенно: никто не мешает
читать  хелп  в  одном экземпляре DN, а экспериментировать в другом.
Но,   тем   не   менее,  надо  будет попробовать сохранить привычное
поведение, если это не будет сложно.
     Так что  пока  делаю так:  ввожу в Views глобальную переменную
ModalCount  с  неизменным  начальным значением 1, а потом, возможно,
введу  для  неё  более  содержательные  присвоения  (начальное  - 0,
работа - считать нанизваемые друг на друга модальные окна).

     Возвращаясь  к  CM_RenameSingleL,  отыгрываю  назад патч SB, то
есть   вставляю   строку  ввода  имени файла прямо в менеджер, как и
раньше.  Почему-то перестаёт прятаться скроллбар, если редактируется
имя  файла  в  крайней правой колонке.  Вставляю явное Hide, нет сил
разбираться.
     Это ak40607b.dif.

     Теперь  попробуем присмотреться к самой строке ввода по Alt-F6.
Она  имеет  тип TInputFName (swe.pas), который больше ни для чего не
используется.  Вообще, swe - это надо видеть. Почти весь текст - это
мусор,  хорошо, что  его отсекает SmartLink. Но лучше всё-таки мусор
вымести. Останутся два интерфейсных типа: TInputFName и TColorPoint.
И  ни  одной процедуры. После этой чистки видно, что вспомогательные
типы   TInpLine  и  TInpString  можно  убрать, а всё, что они делают
осмысленного,  перенести   в  TInputFName,  заодно  убрав  абсурдные
манипуляции со стрелками влево-вправо и с клавишами Enter и Esc.
     Это ak40607c.dif.

     Теперь  становится  интересно,  чем же, собственно, TInputFName
отличается  от  TInputLine, и нет ли в самой TInputLine странностей.
Например,    сразу    настораживает   поле   DrawShift,   которого в
оригинальной  TV  нет.  В  Init присваивается "1", присвоения других
значений в DN OSP есть, как раз в связи с Alt-F6:

  New(PIF, Init(R, 12)); PIF^.DrawShift := 0; P^.Owner^.Insert(PIF);

     В  DN/2  это обнуление как-то рассосалось, притом глюков нет. А
если сделать так, как в DN OSP - глюки по Alt-F6 появляются. Неохота
с  этим  разбираться, лучше додавить эту мёртвую переменную, которая
всегда равна 1. Додавливаю.
     Это ak40607d.dif.

     Видно,   как   минимум,   одну   странность:   TInputFName.Draw
практически дублирует TInputLine.Draw. Надо это устранить. Для этого
разбираюсь, чем же они отличаются.
     В TInputFName используются какие-то поначалу непонятные C1, C2,
C3  в  точности  для  того, для чего обычно используется GetPalette.
Проверяю,  вызывается  ли вообще TInputFName.GetPalette. Так и есть,
не  вызывается.  Эти  C1... нужны потому, что CinpuLine заточена под
вставку  в  диалог,  а  при  вставке  в  десктоп или менеджер ничего
хорошего не получается.
     В  TInputFName  для  крайних  символов  используется или символ
обрезки,  или  символ соответствующей рамки (LC, RC). В TInputLine -
если  не  обрезка,  то  безусловно  пробел.  Можно в TInputLine тоже
ввести   эти   переменные,   инициализированные   пробелом,   а  для
TInputFName поверх пробела записать нужные рамки.
     В  TInputFName  есть  борьба  с серым курсором на сером фоне. В
TInputLine  её  нет,  что огорчает.  Сейчас  таких  строк  ввода  не
бывает,   но   мало   ли  какие  цвета  когда-то  кому-то  захочется
использовать. Это надо просто перенести в TInputLine.
    Теперь  перетаскиваю  всё  полезное  в  TInputLine.Draw и вношу
необходимые дополнения.
    Это ak40607e.dif.

     Теперь  сливаю всё вместе и подчищаю мелочи (в основном, лишние
пустые строки).

     Итог  -  ушло  около 1000 строк исходников и 1k двоичного кода.
Исправлен  глюк  и  подчищено  русло  от подводных камней. Добавлено
немного комментариев. Временно ампутирована фича немодального хелпа.

     Теперь делаем корректную работу с ModalCount. Это ak40607f.dif

     Это ak40607a.dif. А ak40607b,c,d,e,f.dif - выкинуть.
